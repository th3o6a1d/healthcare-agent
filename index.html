<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Healthcare Agent - Browser Edition (WebLLM)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 1200px;
            height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .status {
            font-size: 14px;
            opacity: 0.9;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            background: #f5f5f5;
            scroll-behavior: smooth;
            min-height: 0; /* Important for flex scrolling */
        }

        .message {
            margin-bottom: 16px;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
        }

        .message.user {
            background: #667eea;
            color: white;
            margin-left: auto;
            text-align: right;
        }

        .message.assistant {
            background: white;
            color: #333;
            border: 1px solid #e0e0e0;
        }

        .message.tool {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffc107;
            font-family: monospace;
            font-size: 12px;
            max-width: 100%;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #e0e0e0;
        }

        .input-wrapper {
            display: flex;
            gap: 10px;
        }

        .input-wrapper input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
        }

        .input-wrapper input:focus {
            border-color: #667eea;
        }

        .input-wrapper button {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
        }

        .input-wrapper button:hover:not(:disabled) {
            background: #5568d3;
        }

        .input-wrapper button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .setup {
            padding: 40px;
            text-align: center;
        }

        .setup h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .setup select {
            width: 100%;
            max-width: 500px;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 20px;
            outline: none;
        }

        .setup select:focus {
            border-color: #667eea;
        }

        .setup button {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }

        .setup button:hover {
            background: #5568d3;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        pre {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
            margin-top: 8px;
        }

        .progress {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè• Healthcare Agent (WebLLM)</h1>
            <div class="status" id="status">Initializing...</div>
        </div>
        <div id="content">
            <div class="loading">
                <div class="spinner"></div>
                <div>Loading Pyodide and Python runtime...</div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script type="module">
        let CreateMLCEngine;
        let prebuiltAppConfig;
        let webLLMAvailable = false;

        let pyodide;
        let engine;
        let model = '';
        let messages = [];
        let functions = [];

        // Load WebLLM library
        async function loadWebLLM() {
            if (webLLMAvailable) return true;
            
            // Clear any potentially corrupted cache
            try {
                const cacheNames = await caches.keys();
                for (const cacheName of cacheNames) {
                    if (cacheName.includes('webllm') || cacheName.includes('wasm')) {
                        await caches.delete(cacheName);
                        console.log('Cleared cache:', cacheName);
                    }
                }
            } catch (e) {
                console.warn('Could not clear cache:', e);
            }
            
            // Try multiple CDNs with specific version
            // Using 0.2.79 which is a stable version
            const version = '0.2.79';
            const cdnUrls = [
                // Try unpkg first - it's good at resolving dependencies
                `https://unpkg.com/@mlc-ai/web-llm@${version}?module`,
                // Try esm.sh with explicit external handling
                `https://esm.sh/@mlc-ai/web-llm@${version}`,
                // Try jsdelivr
                `https://cdn.jsdelivr.net/npm/@mlc-ai/web-llm@${version}/+esm`,
                // Try skypack
                `https://cdn.skypack.dev/@mlc-ai/web-llm@${version}`,
            ];
            
            for (const url of cdnUrls) {
                try {
                    console.log(`Trying to load WebLLM from: ${url}`);
                    const module = await import(url);
                    
                    // Check for all expected exports
                    if (module && module.CreateMLCEngine) {
                        CreateMLCEngine = module.CreateMLCEngine;
                        // prebuiltAppConfig contains the model list
                        prebuiltAppConfig = module.prebuiltAppConfig || null;
                        webLLMAvailable = true;
                        console.log('WebLLM loaded successfully from:', url);
                        console.log('Available exports:', Object.keys(module));
                        
                        if (prebuiltAppConfig) {
                            console.log('AppConfig available with', prebuiltAppConfig.model_list?.length || 0, 'models');
                            if (prebuiltAppConfig.model_list && prebuiltAppConfig.model_list.length > 0) {
                                console.log('Sample model IDs:', prebuiltAppConfig.model_list.slice(0, 5).map(m => m.model_id));
                            }
                        } else {
                            console.warn('prebuiltAppConfig not found or is null');
                        }
                        return true;
                    } else {
                        throw new Error('CreateMLCEngine not found in module. Available:', Object.keys(module || {}));
                    }
                } catch (e) {
                    console.warn(`Failed to load from ${url}:`, e.message);
                    if (e.stack) {
                        console.warn('Stack trace:', e.stack);
                    }
                    continue;
                }
            }
            
            console.error('Failed to load WebLLM from all CDNs');
            return false;
        }

        // Initialize Pyodide
        async function initPyodide() {
            try {
                updateStatus('Loading Pyodide...');
                pyodide = await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
                });

                updateStatus('Installing packages...');
                await pyodide.loadPackage(["pandas", "sqlite3"]);
                
                updateStatus('Loading database...');
                await loadDatabase();
                
                updateStatus('Initializing chat system...');
                await initializeChat();
                
                updateStatus('Loading WebLLM library...');
                const webLLMLoaded = await loadWebLLM();
                
                if (!webLLMLoaded) {
                    showError('Failed to load WebLLM library. Please check your internet connection and try again.');
                    return;
                }
                
                updateStatus('Ready');
                showSetup();
            } catch (error) {
                console.error('Initialization error:', error);
                updateStatus('Error: ' + error.message);
                showError('Failed to initialize: ' + error.message);
            }
        }

        // Load the SQLite database file
        async function loadDatabase() {
            try {
                const response = await fetch('synthea_data.db');
                if (!response.ok) {
                    throw new Error('Failed to load database file');
                }
                const arrayBuffer = await response.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                
                // Write database to Pyodide filesystem
                pyodide.FS.writeFile('synthea_data.db', uint8Array);
                console.log('Database loaded successfully');
            } catch (error) {
                console.error('Database load error:', error);
                throw new Error('Failed to load database. Make sure synthea_data.db is available.');
            }
        }

        // Initialize chat system
        async function initializeChat() {
            try {
                // Load the Python modules
                const [chatResponse, sqliteResponse] = await Promise.all([
                    fetch('chat_browser.py'),
                    fetch('tools/sqlite.py')
                ]);
                
                if (!chatResponse.ok || !sqliteResponse.ok) {
                    throw new Error('Failed to load Python files');
                }
                
                const chatCode = await chatResponse.text();
                const sqliteCode = await sqliteResponse.text();
                
                // Create tools directory structure
                pyodide.runPython(`
import sys
import os
os.makedirs('tools', exist_ok=True)
                `);
                
                // Write sqlite.py to filesystem
                pyodide.FS.writeFile('tools/sqlite.py', sqliteCode);
                pyodide.FS.writeFile('tools/__init__.py', '');
                
                // Write and run chat_browser.py
                pyodide.FS.writeFile('chat_browser.py', chatCode);
                pyodide.runPython(chatCode);
                
                // Get function definitions from Python
                const functionsJson = pyodide.runPython(`
import json
from chat_browser import get_functions
json.dumps(get_functions())
                `);
                functions = JSON.parse(functionsJson);
            } catch (error) {
                console.error('Chat initialization error:', error);
                throw new Error('Failed to load chat system: ' + error.message);
            }
        }

        // Initialize WebLLM engine
        async function initWebLLM(selectedModel) {
            try {
                if (!webLLMAvailable || !CreateMLCEngine) {
                    const loaded = await loadWebLLM();
                    if (!loaded) {
                        throw new Error('WebLLM library not available');
                    }
                }
                
                updateStatus('Loading WebLLM model (this may take a minute)...');
                model = selectedModel;
                
                // Check if caches API is available (required for WebLLM)
                const hasCaches = (typeof window !== 'undefined' && 'caches' in window) || typeof caches !== 'undefined';
                if (!hasCaches) {
                    const isLocalhost = window.location.hostname === 'localhost' || 
                                      window.location.hostname === '127.0.0.1' ||
                                      window.location.hostname === '0.0.0.0';
                    if (!isLocalhost && window.location.protocol !== 'https:') {
                        throw new Error('Cache API not available. WebLLM requires HTTPS or localhost. You are accessing from: ' + window.location.hostname + '. Please use http://localhost:8000 instead.');
                    }
                    console.warn('Cache API not detected, but continuing anyway (might work in some browsers)');
                }
                
                // Create WebLLM engine using the correct API
                // CreateMLCEngine requires appConfig with model_list
                const engineConfig = {
                    initProgressCallback: (report) => {
                        if (report && report.text) {
                            updateStatus(`Loading model: ${report.text}`);
                        } else if (typeof report === 'string') {
                            updateStatus(`Loading model: ${report}`);
                        }
                    }
                };
                
                // Add appConfig - required for WebLLM to find models
                if (prebuiltAppConfig) {
                    engineConfig.appConfig = prebuiltAppConfig;
                } else {
                    // Fallback: create minimal appConfig with common model URLs
                    // WebLLM will download models from HuggingFace
                    engineConfig.appConfig = {
                        model_list: [
                            {
                                model_id: model,
                                model_url: `https://huggingface.co/mlc-ai/${model}`,
                            }
                        ]
                    };
                    console.warn('Using fallback appConfig for model:', model);
                }
                
                engine = await CreateMLCEngine(model, engineConfig);
                
                updateStatus('Ready');
                showChat();
            } catch (error) {
                console.error('WebLLM initialization error:', error);
                let errorMsg = 'Failed to load WebLLM model: ' + error.message;
                
                // Provide specific guidance for common errors
                if (error.message.includes('detectGPUDevice') || error.message.includes('not a function')) {
                    errorMsg += '\n\nThis error often indicates a module loading issue. Try:\n';
                    errorMsg += '1. Clear your browser cache (Ctrl+Shift+Delete or Cmd+Shift+Delete)\n';
                    errorMsg += '2. Hard refresh the page (Ctrl+F5 or Cmd+Shift+R)\n';
                    errorMsg += '3. Check the browser console for more details\n';
                    errorMsg += '4. Try a different model\n\n';
                    errorMsg += 'Note: WebLLM requires WebGPU support and may not work in all browsers.';
                }
                
                showError(errorMsg);
            }
        }

        // Show setup screen
        function showSetup() {
            const content = document.getElementById('content');
            
            let availableModels = [];
            
            // Try to get models from prebuiltAppConfig first
            if (prebuiltAppConfig && prebuiltAppConfig.model_list && prebuiltAppConfig.model_list.length > 0) {
                // Filter and sort models from the config
                const models = prebuiltAppConfig.model_list
                    .filter(m => {
                        const id = m.model_id?.toLowerCase() || '';
                        return id.includes('tinyllama') || id.includes('phi-3') || 
                               id.includes('llama-3.1') || id.includes('llama-3.2') || id.includes('llama-3') || 
                               id.includes('mistral');
                    })
                    .sort((a, b) => {
                        // Sort by size: smaller models first
                        const aSize = (a.model_id || '').match(/(\d+\.?\d*)b/i)?.[1] || '999';
                        const bSize = (b.model_id || '').match(/(\d+\.?\d*)b/i)?.[1] || '999';
                        return parseFloat(aSize) - parseFloat(bSize);
                    })
                    .slice(0, 10); // Limit to 10 models
                
                availableModels = models.map(m => {
                    const modelId = m.model_id || '';
                    const size = modelId.match(/(\d+\.?\d*)b/i)?.[1] || '?';
                    // Clean up model name for display
                    let name = modelId
                        .replace(/-MLC$/, '')
                        .replace(/q\d+f\d+_\d+(-\d+k)?/gi, '')
                        .replace(/-/g, ' ')
                        .trim();
                    name = name.replace(/\s+/g, ' ');
                    return { id: modelId, name: name, size: size + 'B' };
                });
            }
            
            // Fallback to hardcoded models if prebuiltAppConfig doesn't have them
            if (availableModels.length === 0) {
                availableModels = [
                    { id: 'Llama-3.2-1B-Instruct-q4f32_1-MLC', name: 'Llama-3.2-1B-Instruct', size: '1B' },
                    { id: 'Llama-3.2-3B-Instruct-q4f32_1-MLC', name: 'Llama-3.2-3B-Instruct', size: '3B' },
                    { id: 'Llama-3.1-8B-Instruct-q4f32_1-MLC', name: 'Llama-3.1-8B-Instruct', size: '8B' },
                    { id: 'Phi-3-mini-4k-instruct-q4f16_1-MLC', name: 'Phi-3-mini-4k-instruct', size: '3.8B' },
                    { id: 'TinyLlama-1.1B-Chat-v0.4-q4f32_1-MLC', name: 'TinyLlama-1.1B-Chat', size: '1.1B' },
                    { id: 'Mistral-7B-Instruct-v0.2-q4f32_1-MLC', name: 'Mistral-7B-Instruct', size: '7B' },
                ];
            }
            
            const modelOptions = availableModels.map(m => 
                `<option value="${m.id}">${m.name} (${m.size})</option>`
            ).join('');
            
            content.innerHTML = `
                <div class="setup">
                    <h2>Select WebLLM Model</h2>
                    <p style="margin-bottom: 20px; color: #666;">Choose a model to run locally in your browser</p>
                    <select id="modelSelect">
                        ${modelOptions}
                    </select>
                    <div class="progress" id="progress"></div>
                    <button onclick="startChat()">Start Chat</button>
                </div>
            `;
        }

        // Start chat
        async function startChat() {
            const selectedModel = document.getElementById('modelSelect').value;
            const button = event.target;
            button.disabled = true;
            button.textContent = 'Loading...';
            
            await initWebLLM(selectedModel);
        }

        // Show chat interface
        function showChat() {
            const content = document.getElementById('content');
            content.innerHTML = `
                <div class="chat-container">
                    <div class="messages" id="messages"></div>
                    <div class="input-container">
                        <div class="input-wrapper">
                            <input type="text" id="userInput" placeholder="Type your message..." onkeypress="handleKeyPress(event)" />
                            <button onclick="sendMessage()" id="sendButton">Send</button>
                        </div>
                    </div>
                </div>
            `;

            // Initialize messages
            messages = [
                {
                    "role": "system",
                    "content": `You are a helpful healthcare assistant that can query patient data and medical records from a SQLite database. 

CRITICAL: You MUST use tools to answer questions about patient data. You cannot answer these questions without using tools.

Available tools:
1. get_db_schema: Get the schema of all tables. Takes NO arguments. Call: {"name": "get_db_schema", "arguments": {}}
2. query_db: Execute SQL SELECT queries. Takes "query" parameter. Call: {"name": "query_db", "arguments": {"query": "SELECT ..."}}
3. get_patient_data: Get patient data. Takes "patient_id" and "tables" parameters. Call: {"name": "get_patient_data", "arguments": {"patient_id": "...", "tables": ["table1", "table2"]}}
4. compare_dates: Compare dates. Takes "date1" and "date2" parameters. Call: {"name": "compare_dates", "arguments": {"date1": "...", "date2": "..."}}

IMPORTANT: 
- get_db_schema takes NO arguments - use empty object: {"arguments": {}}
- query_db takes ONLY "query" parameter - use: {"arguments": {"query": "SELECT ..."}}
- Do NOT mix parameters between tools!

TOOL CALL FORMAT: When you need to use a tool, output ONLY a JSON object in this exact format:
{"name": "tool_name", "arguments": {"param1": "value1", "param2": "value2"}}

WORKFLOW:
1. When asked about patient data, first call get_db_schema to understand the database
2. Then use query_db or get_patient_data to get the information
3. After receiving tool results, provide your answer

EXAMPLE: If asked "What tables are in the database?", output:
{"name": "get_db_schema", "arguments": {}}

IMPORTANT: Output ONLY the JSON tool call, nothing else. Do not include explanations or text before/after the JSON.`,
                }
            ];

            addMessage('assistant', `Healthcare Agent Chat\nUsing model: ${model}\nRunning locally in your browser!\nType your message to get started.`, false);
        }

        // Send message
        async function sendMessage() {
            const input = document.getElementById('userInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            input.value = '';
            document.getElementById('sendButton').disabled = true;
            
            addMessage('user', message);
            
            // Add user message to conversation
            messages.push({"role": "user", "content": message});
            
            try {
                // Chat loop with function calling
                while (true) {
                    // Prepare messages for WebLLM
                    // WebLLM requires last message to be from 'user' or 'tool'
                    // Keep tool messages as-is (they're valid as last message)
                    let chatMessages = messages.map(msg => {
                        // Keep tool messages as tool (WebLLM accepts them)
                        // Only convert format if needed for display, but keep role
                        return msg;
                    });
                    
                    // Ensure last message is from user or tool (not assistant without tool_calls)
                    // Remove trailing assistant messages without tool_calls
                    while (chatMessages.length > 0) {
                        const lastMsg = chatMessages[chatMessages.length - 1];
                        if (lastMsg.role === 'assistant' && !lastMsg.tool_calls) {
                            chatMessages.pop();
                        } else {
                            break;
                        }
                    }
                    
                    // If we removed all messages, add back the last user message
                    if (chatMessages.length === 0 && messages.length > 0) {
                        for (let i = messages.length - 1; i >= 0; i--) {
                            if (messages[i].role === 'user') {
                                chatMessages.push(messages[i]);
                                break;
                            }
                        }
                    }
                    
                    // Call WebLLM with tools
                    // Note: WebLLM function calling is preliminary, so we handle both cases
                    let response;
                    try {
                        response = await engine.chat.completions.create({
                            messages: chatMessages,
                            tools: functions,
                            tool_choice: "auto",
                            temperature: 0.7
                        });
                    } catch (error) {
                        // If tools parameter fails, try without it and parse manually
                        console.warn('Tools parameter not supported, falling back to manual parsing');
                        // Enhance ALL messages with explicit tool usage instructions
                        // Since tools parameter isn't supported, we need to be very explicit in prompts
                        const enhancedMessages = chatMessages.map((m, idx) => {
                            if (m.role === 'user' && idx === chatMessages.length - 1) {
                                // Last user message - add explicit tool call instruction
                                return {
                                    ...m,
                                    content: `${m.content}\n\n[SYSTEM INSTRUCTION: You MUST use a tool to answer this question. Output ONLY a JSON object with this format: {"name": "tool_name", "arguments": {...}}. Available tools: get_db_schema(), query_db(query="SELECT ..."), get_patient_data(patient_id="...", tables=[...]), compare_dates(date1="...", date2="..."). Do not include any text before or after the JSON.]`
                                };
                            } else if (m.role === 'system') {
                                // Enhance system message to be even more explicit
                                return {
                                    ...m,
                                    content: `${m.content}\n\nREMINDER: When you need to use a tool, output ONLY the JSON object. Format: {"name": "tool_name", "arguments": {...}}. Nothing else.`
                                };
                            }
                            return m;
                        });
                        
                        response = await engine.chat.completions.create({
                            messages: enhancedMessages,
                            temperature: 0.3  // Lower temperature for more consistent tool calling
                        });
                    }
                    
                    // Handle response - WebLLM may return async iterable (streaming) or complete response
                    let assistantMessage = { role: 'assistant', content: '', tool_calls: null };
                    let fullContent = '';
                    let toolCalls = [];
                    
                    // Check if response is async iterable (streaming) or a complete response
                    if (response && typeof response[Symbol.asyncIterator] === 'function') {
                        // Streaming response
                        for await (const chunk of response) {
                            const choice = chunk.choices?.[0];
                            if (choice?.delta?.content) {
                                fullContent += choice.delta.content;
                                // Update message in real-time
                                updateLastMessage('assistant', fullContent);
                            }
                            if (choice?.delta?.tool_calls) {
                                choice.delta.tool_calls.forEach(toolCall => {
                                    const index = toolCall.index || 0;
                                    if (!toolCalls[index]) {
                                        toolCalls[index] = {
                                            id: toolCall.id || `call_${Date.now()}_${index}`,
                                            type: 'function',
                                            function: { name: '', arguments: '' }
                                        };
                                    }
                                    if (toolCall.function?.name) {
                                        toolCalls[index].function.name = toolCall.function.name;
                                    }
                                    if (toolCall.function?.arguments) {
                                        toolCalls[index].function.arguments += toolCall.function.arguments;
                                    }
                                });
                            }
                        }
                        assistantMessage.content = fullContent;
                        if (toolCalls.length > 0) {
                            assistantMessage.tool_calls = toolCalls;
                        }
                    } else {
                        // Non-streaming response - complete response object
                        // response might be a promise or already resolved
                        const resolvedResponse = response && typeof response.then === 'function' 
                            ? await response 
                            : response;
                        
                        const choice = resolvedResponse?.choices?.[0];
                        if (choice?.message?.content) {
                            fullContent = choice.message.content;
                            assistantMessage.content = fullContent;
                            updateLastMessage('assistant', fullContent);
                        }
                        if (choice?.message?.tool_calls) {
                            assistantMessage.tool_calls = choice.message.tool_calls.map(tc => ({
                                id: tc.id,
                                type: tc.type || 'function',
                                function: {
                                    name: tc.function?.name || '',
                                    arguments: typeof tc.function?.arguments === 'string' 
                                        ? tc.function.arguments 
                                        : JSON.stringify(tc.function?.arguments || {})
                                }
                            }));
                        }
                    }
                    
                    // Try to parse function calls from text if not provided by API
                    if (!assistantMessage.tool_calls && fullContent) {
                        console.log('Attempting to parse tool calls from content:', fullContent.substring(0, 200));
                        const parsedCalls = parseFunctionCallsFromText(fullContent);
                        if (parsedCalls.length > 0) {
                            console.log('Successfully parsed tool calls:', parsedCalls);
                            assistantMessage.tool_calls = parsedCalls;
                            // If we found a tool call, clear the content (it's just the JSON)
                            // unless it contains explanatory text
                            if (fullContent.trim().match(/^[\s\n]*\{[\s\S]*\}[\s\n]*$/)) {
                                assistantMessage.content = '';
                            }
                        } else {
                            console.log('No tool calls found in content');
                        }
                    }
                    
                    // Check if function call is needed
                    if (assistantMessage.tool_calls && assistantMessage.tool_calls.length > 0) {
                        // Add assistant message with tool_calls (but no content yet)
                        // WebLLM requires: assistant (with tool_calls) -> tool -> assistant (with content)
                        messages.push({
                            role: 'assistant',
                            tool_calls: assistantMessage.tool_calls,
                            content: assistantMessage.content || null
                        });
                        
                        // Execute function calls
                        for (const toolCall of assistantMessage.tool_calls) {
                            const functionName = toolCall.function?.name;
                            let argumentsJson = toolCall.function?.arguments || '{}';
                            
                            if (!functionName) {
                                console.warn('Tool call missing function name');
                                continue;
                            }
                            
                            try {
                                // Try to parse arguments to validate JSON
                                const args = JSON.parse(argumentsJson);
                                
                                // Validate arguments for each function
                                if (functionName === 'get_db_schema') {
                                    // get_db_schema takes no arguments
                                    if (Object.keys(args).length > 0) {
                                        throw new Error('get_db_schema takes no arguments. If you need to run a query, use query_db instead.');
                                    }
                                } else if (functionName === 'query_db') {
                                    // query_db requires "query" parameter
                                    if (!args.query) {
                                        throw new Error('query_db requires "query" parameter');
                                    }
                                } else if (functionName === 'get_patient_data') {
                                    // get_patient_data requires patient_id and tables
                                    if (!args.patient_id || !args.tables) {
                                        throw new Error('get_patient_data requires "patient_id" and "tables" parameters');
                                    }
                                } else if (functionName === 'compare_dates') {
                                    // compare_dates requires date1 and date2
                                    if (!args.date1 || !args.date2) {
                                        throw new Error('compare_dates requires "date1" and "date2" parameters');
                                    }
                                }
                                
                                // Display tool call
                                addMessage('tool', `[Tool Call: ${functionName}]\nArguments: ${JSON.stringify(args, null, 2)}`);
                                
                                // Execute function in Python
                                const escapedArgs = argumentsJson.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n');
                                const resultJson = await pyodide.runPythonAsync(`
import json
from chat_browser import execute_tool
execute_tool('${functionName}', '''${escapedArgs}''')
                                `);
                                
                                const result = JSON.parse(resultJson);
                                const functionResult = result.success ? result.result : `Error: ${result.error}`;
                                
                                // Display result
                                addMessage('tool', `Result: ${functionResult}`);
                                
                                // Add function result to messages
                                messages.push({
                                    "role": "tool",
                                    "tool_call_id": toolCall.id || `call_${Date.now()}`,
                                    "content": functionResult
                                });
                            } catch (parseError) {
                                console.error('Error parsing tool call arguments:', parseError);
                                addMessage('error', `Error parsing function call: ${parseError.message}`);
                                // Continue anyway - maybe the arguments are incomplete
                            }
                        }
                        
                        // After tool execution, the last message is a tool message, which is valid
                        // Continue loop to get assistant response with content
                        continue;
                    } else {
                        // No function call - add assistant message with content and we're done
                        if (assistantMessage.content) {
                            messages.push({
                                role: 'assistant',
                                content: assistantMessage.content
                            });
                        }
                        // No function call, we're done
                        break;
                    }
                }
            } catch (error) {
                console.error('Chat error:', error);
                addMessage('error', 'Error: ' + error.message);
            } finally {
                document.getElementById('sendButton').disabled = false;
                document.getElementById('userInput').focus();
            }
        }

        // Handle Enter key
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // Scroll to bottom helper
        function scrollToBottom(messagesDiv, force = false) {
            if (!messagesDiv) return;
            
            // Check if user is near bottom (within 100px) or force scroll
            const isNearBottom = messagesDiv.scrollHeight - messagesDiv.scrollTop - messagesDiv.clientHeight < 100;
            
            if (force || isNearBottom) {
                // Use multiple methods to ensure scrolling happens
                const scroll = () => {
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                };
                
                // Try immediately
                scroll();
                
                // Try after animation frame
                requestAnimationFrame(() => {
                    scroll();
                });
                
                // Try after a short delay to ensure layout is complete
                setTimeout(() => {
                    scroll();
                }, 10);
                
                // Try one more time after a slightly longer delay
                setTimeout(() => {
                    scroll();
                }, 50);
            }
        }

        // Add message to chat
        function addMessage(type, content, autoScroll = true) {
            const messagesDiv = document.getElementById('messages');
            if (!messagesDiv) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.id = `msg-${Date.now()}`;
            
            // Format content (preserve line breaks)
            let formattedContent = content;
            if (formattedContent.includes('\n')) {
                formattedContent = formattedContent.split('\n').map(line => {
                    if (line.trim().startsWith('Result:') || line.trim().startsWith('Arguments:')) {
                        return `<pre>${escapeHtml(line)}</pre>`;
                    }
                    return escapeHtml(line);
                }).join('<br>');
            } else {
                formattedContent = escapeHtml(formattedContent);
            }
            
            messageDiv.innerHTML = formattedContent;
            messagesDiv.appendChild(messageDiv);
            
            if (autoScroll) {
                // Always scroll when adding new messages
                // Use setTimeout to ensure DOM is updated before scrolling
                setTimeout(() => {
                    scrollToBottom(messagesDiv, true);
                }, 0);
            }
            
            return messageDiv;
        }

        // Update last message (for streaming)
        function updateLastMessage(type, content) {
            const messagesDiv = document.getElementById('messages');
            if (!messagesDiv) return;
            
            let lastMsg = messagesDiv.querySelector(`.message.${type}:last-child`);
            if (!lastMsg) {
                lastMsg = addMessage(type, '', false);
            }
            
            // Format content
            let formattedContent = content;
            if (formattedContent.includes('\n')) {
                formattedContent = formattedContent.split('\n').map(line => escapeHtml(line)).join('<br>');
            } else {
                formattedContent = escapeHtml(formattedContent);
            }
            
            lastMsg.innerHTML = formattedContent;
            
            // Smooth scroll to bottom during streaming updates
            // Only scroll if user is near bottom (they might be reading)
            // Use setTimeout to ensure DOM is updated
            setTimeout(() => {
                scrollToBottom(messagesDiv, false);
            }, 0);
        }

        // Parse function calls from text (fallback if API doesn't support it)
        function parseFunctionCallsFromText(text) {
            const toolCalls = [];
            
            if (!text || typeof text !== 'string') {
                return toolCalls;
            }
            
            // First, try to parse the entire response as JSON (in case it's just a JSON object)
            const trimmed = text.trim();
            if (trimmed.startsWith('{') && trimmed.endsWith('}')) {
                try {
                    const parsed = JSON.parse(trimmed);
                    if (parsed.name && parsed.arguments && 
                        ['query_db', 'get_db_schema', 'get_patient_data', 'compare_dates'].includes(parsed.name)) {
                        console.log('Found complete JSON tool call:', parsed);
                        toolCalls.push({
                            id: `call_${Date.now()}_${toolCalls.length}`,
                            type: 'function',
                            function: {
                                name: parsed.name,
                                arguments: typeof parsed.arguments === 'string' 
                                    ? parsed.arguments 
                                    : JSON.stringify(parsed.arguments)
                            }
                        });
                        return toolCalls;
                    }
                } catch (e) {
                    // Not a valid JSON, continue with pattern matching
                }
            }
            
            // Try to find JSON-style tool calls in the text
            // Look for patterns like: {"name": "query_db", "arguments": {...}}
            // Use a more robust regex that handles nested JSON in arguments
            const jsonToolCallPattern = /\{[\s\n]*"name"[\s\n]*:[\s\n]*"([^"]+)"[\s\n]*,[\s\n]*"arguments"[\s\n]*:[\s\n]*(\{[\s\S]*?\})[\s\n]*\}/gi;
            let match;
            while ((match = jsonToolCallPattern.exec(text)) !== null) {
                try {
                    const functionName = match[1];
                    let argsJson = match[2];
                    // Validate it's a valid function name
                    if (['query_db', 'get_db_schema', 'get_patient_data', 'compare_dates'].includes(functionName)) {
                        // Try to parse and re-stringify to validate JSON
                        try {
                            const parsedArgs = JSON.parse(argsJson);
                            argsJson = JSON.stringify(parsedArgs);
                        } catch (e) {
                            console.warn('Arguments JSON not valid, using as-is:', e);
                        }
                        
                        console.log('Parsed tool call from text:', functionName, argsJson);
                        toolCalls.push({
                            id: `call_${Date.now()}_${toolCalls.length}`,
                            type: 'function',
                            function: {
                                name: functionName,
                                arguments: argsJson
                            }
                        });
                    }
                } catch (e) {
                    console.warn('Failed to parse JSON tool call:', e);
                }
            }
            
            // If no JSON found, try to parse function calls from text patterns
            if (toolCalls.length === 0) {
                // Look for patterns like: query_db(query="SELECT ...")
                const functionPatterns = [
                    { 
                        name: 'query_db', 
                        regex: /query_db\s*\(\s*query\s*[:=]\s*["']([^"']+)["']/gi,
                        extractArgs: (match) => ({ query: match[1] })
                    },
                    { 
                        name: 'get_db_schema', 
                        regex: /get_db_schema\s*\(/gi,
                        extractArgs: () => ({})
                    },
                    { 
                        name: 'get_patient_data', 
                        regex: /get_patient_data\s*\(\s*patient_id\s*[:=]\s*["']([^"']+)["']/gi,
                        extractArgs: (match) => ({ patient_id: match[1], tables: [] })
                    },
                    { 
                        name: 'compare_dates', 
                        regex: /compare_dates\s*\(\s*date1\s*[:=]\s*["']([^"']+)["']\s*,\s*date2\s*[:=]\s*["']([^"']+)["']/gi,
                        extractArgs: (match) => ({ date1: match[1], date2: match[2] })
                    }
                ];
                
                for (const pattern of functionPatterns) {
                    const regex = new RegExp(pattern.regex.source, 'gi');
                    let match;
                    while ((match = regex.exec(text)) !== null) {
                        try {
                            const args = pattern.extractArgs ? pattern.extractArgs(match) : {};
                            toolCalls.push({
                                id: `call_${Date.now()}_${toolCalls.length}`,
                                type: 'function',
                                function: {
                                    name: pattern.name,
                                    arguments: JSON.stringify(args)
                                }
                            });
                            // Only take first match per function
                            break;
                        } catch (e) {
                            console.warn(`Failed to parse ${pattern.name} call:`, e);
                        }
                    }
                }
            }
            
            return toolCalls;
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Update status
        function updateStatus(text) {
            const statusEl = document.getElementById('status');
            if (statusEl) {
                statusEl.textContent = text;
            }
        }

        // Show error
        function showError(message) {
            const content = document.getElementById('content');
            content.innerHTML = `
                <div class="setup">
                    <h2 style="color: #d32f2f;">Error</h2>
                    <p>${message}</p>
                    <button onclick="location.reload()">Reload</button>
                </div>
            `;
        }

        // Make functions globally available
        window.sendMessage = sendMessage;
        window.handleKeyPress = handleKeyPress;
        window.startChat = startChat;

        // Start initialization
        initPyodide();
    </script>
</body>
</html>
